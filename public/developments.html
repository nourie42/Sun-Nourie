<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gas Station Developments — Town Search (Fixed)</title>
  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <!-- Leaflet marker cluster CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
  />
  <!-- Layout styles -->
  <style>
    :root {
      --bg: #0b0e15;
      --panel: #111725;
      --panel2: #0e1626;
      --text: #e8eefc;
      --muted: #9fb0cf;
      --accent: #5ec2ff;
      --line: #263145;
      --warn: #ffe08a;
    }
    html,
    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      height: 100%;
    }
    .wrap {
      max-width: 1250px;
      margin: 20px auto;
      padding: 0 14px;
    }
    header {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 10px;
    }
    h1 {
      margin: 0;
      font-size: 1.6rem;
      letter-spacing: 0.2px;
    }
    .spacer {
      flex: 1;
    }
    .btn {
      background: var(--accent);
      color: #00121e;
      border: 0;
      border-radius: 10px;
      padding: 0.6rem 1rem;
      font-weight: 700;
      cursor: pointer;
    }
    .btn.ghost {
      background: #0f2236;
      border: 1px solid var(--line);
      color: #bfe6ff;
    }
    .btn.small {
      padding: 0.45rem 0.75rem;
      font-weight: 600;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      margin: 12px 0;
    }
    label {
      display: block;
      margin: 0.25rem 0 0.35rem;
      color: var(--muted);
    }
    input[type="text"],
    input[type="number"] {
      width: 100%;
      padding: 0.75rem;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: #0f1421;
      color: var(--text);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 0.95rem;
    }
    th,
    td {
      border-bottom: 1px solid var(--line);
      text-align: left;
      padding: 0.6rem 0.5rem;
      vertical-align: top;
    }
    th {
      color: var(--muted);
      font-weight: 600;
    }
        #map {
          /* Hide the interactive map on the live site. Users reported issues with
             map rendering, so we revert to table-only mode. */
          display: none !important;
          height: 0;
          border: 0;
          margin: 0;
        }
    .hint {
      color: var(--muted);
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Gas Station Developments — Town Search (≤ 20 miles)</h1>
    </header>
    <div class="card">
      <label for="q">Town (use “Town, ST”)</label>
      <input id="q" type="text" placeholder="e.g., Knightdale, NC" />
      <div style="margin-top: 8px; display: flex; gap: 12px; align-items: flex-end;">
        <div style="flex: 1;">
          <label for="miles">Miles radius</label>
          <input id="miles" type="number" min="1" max="50" value="20" />
        </div>
        <div style="display: flex; gap: 8px;">
          <button id="go" class="btn">Search</button>
          <button id="clear" class="btn ghost">Clear</button>
        </div>
      </div>
      <div class="hint">You’ll see results only if the town is on the list or within the miles radius from it.</div>
      <div id="results"></div>
      <button id="dlResults" class="btn small" style="margin-top: 8px;">Download results CSV</button>
    </div>
    <div id="map"></div>
  </div>
  <!-- Leaflet JS and marker cluster -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <!-- Papa Parse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    // Data array loaded from CSV
    let DATA = [];
    let CURRENT_RESULTS = [];
    // Helper to escape HTML
    function esc(s) {
      return (s ?? '').toString().replace(/[&<>]/g, (m) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m]));
    }
    // Haversine distance in miles
    function haversineMi(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const toRad = (d) => (d * Math.PI) / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) *
          Math.cos(toRad(lat2)) *
          Math.sin(dLon / 2) ** 2;
      const d = 2 * R * Math.asin(Math.sqrt(a));
      return d / 1609.344;
    }
    // Load CSV dataset
    async function loadData() {
      try {
        const resp = await fetch('developments_data.csv', { cache: 'no-store' });
        if (!resp.ok) throw new Error(resp.status);
        const text = await resp.text();
        const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
            DATA = parsed.data.map((row) => {
              // Determine a reasonable town and state for each row.  The dataset
              // has multiple possible fields for the locality (e.g. City/County,
              // Town, City) and state.  We pick the first non-empty value.
              const townCandidate =
                row.town ||
                row.Town ||
                row["City/County"] ||
                row["City/County.1"] ||
                row["City/County.2"] ||
                row.city ||
                row.City ||
                row.County ||
                '';
              const stateCandidate =
                row.state ||
                row.State ||
                row.STATE ||
                row.ST ||
                row["City/County.2"] ||
                '';
              // parse numeric latitude/longitude if available
              const latVal =
                parseFloat(
                  row.lat ||
                    row.latitude ||
                    row.y ||
                    row.centroid_y ||
                    ''
                );
              const lonVal =
                parseFloat(
                  row.lon ||
                    row.lng ||
                    row.longitude ||
                    row.x ||
                    row.centroid_x ||
                    ''
                );
              // Precompute fallback state centroid
              const stateKey = (stateCandidate || '').toString().trim().toUpperCase();
              const sc = STATE_CENTERS[stateKey] || null;
              // Compute additional fields for display.  Many rows in the dataset
              // use generic column names (e.g. Brand, Status, Details).  We
              // derive name, developer, date and notes from the first non-empty
              // candidate fields on the row.
              const nameCandidate =
                row.name ||
                row.Name ||
                row.brand ||
                row.Brand ||
                row['Brand'] ||
                row['Brand.1'] ||
                '';
              const developerCandidate =
                row.developer ||
                row.Developer ||
                row['Developer'] ||
                '';
              const dateCandidate =
                row.date ||
                row.Date ||
                row['Date'] ||
                row['Date.1'] ||
                row['Date.2'] ||
                '';
              const statusCandidate = row.status || row.Status || '';
              const detailsCandidate = row.details || row.Details || row['Details'] || row['Details.1'] || row['Details.2'] || '';
              let notesVal = '';
              if (statusCandidate) notesVal += statusCandidate;
              if (detailsCandidate) {
                if (notesVal) notesVal += ' — ';
                notesVal += detailsCandidate;
              }
              return {
                ...row,
                // attach town/state fields so the search/geocode logic can find them
                town: (townCandidate || '').toString().trim(),
                state: (stateCandidate || '').toString().trim(),
                // use parsed coordinates if valid; otherwise fall back to state center
                lat: Number.isFinite(latVal) ? latVal : sc ? sc.lat : null,
                lon: Number.isFinite(lonVal) ? lonVal : sc ? sc.lon : null,
                // new descriptive fields for table
                name: (nameCandidate || '').toString().trim(),
                developer: (developerCandidate || '').toString().trim(),
                date: (dateCandidate || '').toString().trim(),
                notes: notesVal,
              };
            });
        // Show basic dataset count in the results area
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = `<div class="hint">Dataset rows: <b>${DATA.length}</b></div>`;

        // Immediately render all markers on the map and list them in the table.  On the live
        // site there are occasionally issues with geocoding and searching; by
        // plotting everything up front users can see that the data loaded and the
        // map is working.  If you prefer not to show all rows initially you can
        // comment out the following two calls.
            try {
              // Render the results table immediately.  We intentionally do not
              // call updateMap() here because the interactive map has been
              // removed to improve stability.
              renderResults(DATA);
            } catch (e) {
              console.error('Error rendering initial data:', e);
            }
      } catch (e) {
        document.getElementById('results').innerHTML = `<div style="color: var(--warn)">Could not load <b>developments_data.csv</b>. Ensure it is placed next to this page.</div>`;
      }
    }
        // Precomputed approximate lat/lon for each US state (geographic center).
        // These are used as a fallback when no explicit coordinates are provided in
        // the dataset and when geocoding is unavailable.  Coordinates are
        // approximate and based on general state centroids.
        const STATE_CENTERS = {
          AL: { lat: 32.806671, lon: -86.791130 },
          AK: { lat: 61.370716, lon: -152.404419 },
          AZ: { lat: 33.729759, lon: -111.431221 },
          AR: { lat: 34.969704, lon: -92.373123 },
          CA: { lat: 36.116203, lon: -119.681564 },
          CO: { lat: 39.059811, lon: -105.311104 },
          CT: { lat: 41.597782, lon: -72.755371 },
          DE: { lat: 39.318523, lon: -75.507141 },
          FL: { lat: 27.766279, lon: -81.686783 },
          GA: { lat: 33.040619, lon: -83.643074 },
          HI: { lat: 21.094318, lon: -157.498337 },
          ID: { lat: 44.240459, lon: -114.478828 },
          IL: { lat: 40.349457, lon: -88.986137 },
          IN: { lat: 39.849426, lon: -86.258278 },
          IA: { lat: 42.011539, lon: -93.210526 },
          KS: { lat: 38.526600, lon: -96.726486 },
          KY: { lat: 37.668140, lon: -84.670067 },
          LA: { lat: 31.169546, lon: -91.867805 },
          ME: { lat: 44.693947, lon: -69.381927 },
          MD: { lat: 39.063946, lon: -76.802101 },
          MA: { lat: 42.230171, lon: -71.530106 },
          MI: { lat: 43.326618, lon: -84.536095 },
          MN: { lat: 45.694454, lon: -93.900192 },
          MS: { lat: 32.741646, lon: -89.678696 },
          MO: { lat: 38.456085, lon: -92.288368 },
          MT: { lat: 46.921925, lon: -110.454353 },
          NE: { lat: 41.125370, lon: -98.268082 },
          NV: { lat: 38.313515, lon: -117.055374 },
          NH: { lat: 43.452492, lon: -71.563896 },
          NJ: { lat: 40.298904, lon: -74.521011 },
          NM: { lat: 34.840515, lon: -106.248482 },
          NY: { lat: 42.165726, lon: -74.948051 },
          NC: { lat: 35.630066, lon: -79.806419 },
          ND: { lat: 47.528912, lon: -99.784012 },
          OH: { lat: 40.388783, lon: -82.764915 },
          OK: { lat: 35.565342, lon: -96.928917 },
          OR: { lat: 44.572021, lon: -122.070938 },
          PA: { lat: 40.590752, lon: -77.209755 },
          RI: { lat: 41.680893, lon: -71.511780 },
          SC: { lat: 33.856892, lon: -80.945007 },
          SD: { lat: 44.299782, lon: -99.438828 },
          TN: { lat: 35.747845, lon: -86.692345 },
          TX: { lat: 31.054487, lon: -97.563461 },
          UT: { lat: 40.150032, lon: -111.862434 },
          VT: { lat: 44.045876, lon: -72.710686 },
          VA: { lat: 37.769337, lon: -78.169968 },
          WA: { lat: 47.400902, lon: -121.490494 },
          WV: { lat: 38.491226, lon: -80.954453 },
          WI: { lat: 44.268543, lon: -89.616508 },
          WY: { lat: 42.755966, lon: -107.302490 },
          DC: { lat: 38.897438, lon: -77.026817 }
        };

        // Initialize map
    const map = L.map('map').setView([37.8, -96], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap',
    }).addTo(map);
    const markersLayer = L.layerGroup().addTo(map);
    function updateMap(rows) {
      markersLayer.clearLayers();
      if (!rows || !rows.length) return;
      const bounds = [];
      rows.forEach((r) => {
        if (Number.isFinite(r.lat) && Number.isFinite(r.lon)) {
          const marker = L.marker([r.lat, r.lon]).addTo(markersLayer);
          let popup = `<b>${esc(r.name || '')}</b>`;
          if (r.address) popup += `<br>${esc(r.address)}`;
          if (r.town || r.state) popup += `<br>${esc(r.town || '')}${r.town && r.state ? ', ' : ''}${esc(r.state || '')}`;
          if (r.developer) popup += `<br><i>${esc(r.developer)}</i>`;
          if (r.date) popup += `<br>${esc(r.date)}`;
          if (r.url) popup += `<br><a href="${esc(r.url)}" target="_blank" rel="noopener">source</a>`;
          marker.bindPopup(popup);
          bounds.push([r.lat, r.lon]);
        }
      });
      if (bounds.length) map.fitBounds(bounds, { padding: [30, 30] });
    }
    // ------------------------------------------------------------------------
    // Geocode cache and helper: resolve a town/state to lat/lon using Nominatim
    //
    // Many rows in the dataset do not include latitude/longitude.  To display
    // these results on the map we approximate their location by geocoding
    // the town and state.  Results are cached to avoid repeated API calls.
    const __geocodeCache = {};
    async function geocodeTownState(town, state) {
      if (!town) return null;
      const key = `${town}, ${state || ''}`.trim();
      if (__geocodeCache[key]) return __geocodeCache[key];
      try {
        const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&q=${encodeURIComponent(key)}`;
        const resp = await fetch(url, { headers: { Accept: 'application/json' } });
        const data = await resp.json();
        if (data && data.length) {
          const coords = { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
          __geocodeCache[key] = coords;
          return coords;
        }
      } catch (e) {
        // ignore geocoding errors
      }
      __geocodeCache[key] = null;
      return null;
    }

    // Search handler
    async function doSearch() {
      const townInput = document.getElementById('q').value.trim();
      const miles = Math.max(1, +document.getElementById('miles').value || 20);
      if (!townInput) {
        alert('Please enter a town (e.g., "Knightdale, NC").');
        return;
      }
      // Geocode the search town (centre point)
      let centerLat, centerLon;
      try {
        const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&q=${encodeURIComponent(townInput)}`;
        const resp = await fetch(url, { headers: { Accept: 'application/json' } });
        const data = await resp.json();
        if (!data.length) throw new Error('No match');
        centerLat = parseFloat(data[0].lat);
        centerLon = parseFloat(data[0].lon);
      } catch (e) {
        alert('Could not geocode that town. Try a different query.');
        return;
      }
      // For each row, compute distance using either its own coords or a geocoded town
      const results = [];
      for (const row of DATA) {
        let rowLat = Number.isFinite(row.lat) ? row.lat : null;
        let rowLon = Number.isFinite(row.lon) ? row.lon : null;
        // If lat/lon not provided, geocode the town/state
        if (rowLat === null || rowLon === null) {
          if (row.town) {
            const coords = await geocodeTownState(row.town, row.state);
            if (coords) {
              rowLat = coords.lat;
              rowLon = coords.lon;
            }
          }
        }
        if (rowLat !== null && rowLon !== null) {
          const dMi = haversineMi(centerLat, centerLon, rowLat, rowLon);
          if (dMi <= miles) {
            results.push({ ...row, lat: rowLat, lon: rowLon, dist: dMi });
          }
        } else {
          // As a last fallback, include rows with matching town even without coords
          if (row.town && row.town.toLowerCase() === townInput.split(',')[0].trim().toLowerCase()) {
            results.push({ ...row, dist: null });
          }
        }
      }
      // Sort results by distance (null distances at end)
      results.sort((a, b) => {
        if (a.dist === null && b.dist === null) return 0;
        if (a.dist === null) return 1;
        if (b.dist === null) return -1;
        return a.dist - b.dist;
      });
          CURRENT_RESULTS = results;
          renderResults(results);
          // Do not call updateMap() because the map has been removed
    }
    function renderResults(rows) {
      if (!rows || !rows.length) {
        document.getElementById('results').innerHTML = '<div class="hint">No results.</div>';
        return;
      }
      let html = '<table><thead><tr><th>#</th><th>Town</th><th>State</th><th>Name</th><th>Developer</th><th>Date</th><th>Notes</th><th>Dist (mi)</th></tr></thead><tbody>';
      rows.forEach((r, i) => {
        html += `<tr><td>${i + 1}</td><td>${esc(r.town || '')}</td><td>${esc(
          r.state || ''
        )}</td><td>${esc(r.name || '')}</td><td>${esc(r.developer || '')}</td><td>${esc(
          r.date || ''
        )}</td><td>${esc(r.notes || '')}</td><td>${r.dist === null ? '' : r.dist.toFixed(2)}</td></tr>`;
      });
      html += '</tbody></table>';
      document.getElementById('results').innerHTML = html;
    }
    // Download CSV of current results
    function downloadResults() {
      if (!CURRENT_RESULTS || !CURRENT_RESULTS.length) {
        alert('No results to export. Run a search first.');
        return;
      }
      const cols = Object.keys(CURRENT_RESULTS[0]);
      const quote = (v) => '"' + String(v ?? '').replace(/"/g, '""') + '"';
      let csv = cols.map(quote).join(',') + '\n';
      CURRENT_RESULTS.forEach((row) => {
        csv += cols.map((c) => quote(row[c])).join(',') + '\n';
      });
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'developments_results.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    // Event listeners
    document.getElementById('go').addEventListener('click', doSearch);
    document.getElementById('clear').addEventListener('click', () => {
      document.getElementById('q').value = '';
      document.getElementById('results').innerHTML = `<div class="hint">Dataset rows: <b>${DATA.length}</b></div>`;
      map.setView([37.8, -96], 4);
      markersLayer.clearLayers();
    });
    document.getElementById('dlResults').addEventListener('click', downloadResults);
    // Load data on startup
    loadData();
  </script>
</body>
</html>