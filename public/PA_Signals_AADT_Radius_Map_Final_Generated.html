<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PA Signals ➜ AADT Finder (Fixed)</title>
  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-oH+m3bT+rXMIJ0z04feQ5Ct2/C/48RQGgZ7t2m1vTyk="
    crossorigin=""
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"
  />
  <style>
    :root {
      --bg: #0b0e15;
      --panel: #111725;
      --panel2: #0f1421;
      --line: #263145;
      --text: #e8eefc;
      --accent: #6cc3ff;
    }
    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, Segoe UI, Arial, sans-serif;
    }
    #app {
      display: grid;
      grid-template-columns: 380px 1fr;
      height: 100%;
    }
    #sidebar {
      background: var(--panel);
      border-right: 1px solid var(--line);
      padding: 14px 14px 0;
      overflow: auto;
    }
    h1 {
      font-size: 18px;
      margin: 8px 0 12px;
      letter-spacing: 0.2px;
    }
    label {
      display: block;
      font-size: 12px;
      margin: 10px 0 6px;
      color: #bcd;
    }
    input,
    select,
    button {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: var(--panel2);
      color: var(--text);
    }
    input::placeholder {
      color: #8aa;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    button {
      cursor: pointer;
      background: #1b8ae6;
      border-color: #1b8ae6;
      font-weight: 600;
      margin-top: 10px;
      color: #fff;
    }
    button:hover {
      filter: brightness(1.1);
    }
    /*
     * The map container must have an explicit height; otherwise the Leaflet
     * map will not render. A min-height ensures there is always space for
     * the map even if the parent container collapses. The height is also
     * set to 100% so that the grid row can expand to fill the viewport.
     */
        /*
         * Ensure the map container always has a fixed height.  Using only
         * percentage heights on flex/grid parents can collapse the map to
         * zero height when the containing rows have no intrinsic size.  A
         * minimum height keeps the map visible, and a viewport-based height
         * lets it expand on taller screens.
         */
        #map {
          min-height: 600px;
          /* Fill the remaining viewport height minus a small margin */
          height: calc(100vh - 120px);
          width: 100%;
        }
    .summary {
      margin: 12px 0 6px;
      font-size: 12px;
      color: #cfe;
      opacity: 0.9;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0 16px;
      font-size: 12px;
    }
    th,
    td {
      padding: 6px;
      border-bottom: 1px solid #22324a;
      vertical-align: top;
    }
    th {
      position: sticky;
      top: 0;
      background: var(--panel);
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="sidebar">
      <h1>PA Signals ➜ AADT Finder</h1>
      <label for="addr">Address (type anything: "123 Main St, Pittsburgh, PA")</label>
      <input id="addr" placeholder="Enter address." />
      <div class="row">
        <div>
          <label for="radius">Radius</label>
          <select id="radius">
            <option value="0.5">0.5 mi</option>
            <option value="1" selected>1 mi</option>
            <option value="2">2 mi</option>
            <option value="5">5 mi</option>
            <option value="10">10 mi</option>
          </select>
        </div>
        <div>
          <label for="limit">Max results</label>
          <select id="limit">
            <option value="50" selected>50</option>
            <option value="100">100</option>
            <option value="500">500</option>
            <option value="999999">All</option>
          </select>
        </div>
      </div>
      <button id="go">Find Nearby AADT</button>
      <button id="refresh">Refresh Map</button>
      <button id="export">Export CSV</button>
      <div class="summary" id="summary">Type an address and press “Find Nearby AADT”.</div>
      <table id="results">
        <thead>
          <tr>
            <th>#</th>
            <th>SIGNAL_ID</th>
            <th>AADT</th>
            <th>Truck %</th>
            <th>Route</th>
            <th>Dist (mi)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div id="map"></div>
  </div>
  <!-- Leaflet JS and plugins -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-oQWkG8BGm2PRm5WP9NcxNvC8+XGmtdcwGh/2SYJiNys="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  <script>
    /*
     * Dynamically fetch the signals dataset and initialize the map. On Render,
     * the local signals.js file is served as HTML and cannot be parsed as
     * JavaScript. To avoid this, we load the raw JS from GitHub and parse the
     * array from it. Once loaded, markers are added to a Leaflet map and the
     * search/filter/export functionality is wired up.
     */
    async function fetchSignals() {
      /*
       * Fetch the signals dataset from the local signals.js file. On Render
       * the signals.js file is served wrapped in a <pre> tag rather than
       * executing as JavaScript, so we treat it as plain text and extract
       * the JSON array manually. We look for the first square‑bracketed
       * sequence (e.g. [ {...}, {...}, ... ]) and parse it. If that fails
       * we attempt to evaluate the file to capture a global SIGNALS
       * variable. If all methods fail, we return an empty array.
       */
           // Use a relative path when fetching the signals dataset.  When this
           // page is served from a subpath (e.g. on Render), requests like
           // `/signals.js` may be routed back to the index page instead of
           // returning the data file.  Prefixing the path with `./` forces
           // the browser to resolve it relative to the current document,
           // ensuring the correct file is requested.
           const url = './signals.js';
      try {
        const resp = await fetch(url, { cache: 'no-store' });
        const text = await resp.text();
        // Try to find a JSON array inside the file. The dataset is declared
        // as `const SIGNALS = [ ... ];`, but the server may wrap it in HTML.
        let arrayText = null;
        const arrayMatch = text.match(/\[[\s\S]*?\]/);
        if (arrayMatch) {
          arrayText = arrayMatch[0];
        } else {
          // If the file is wrapped in <pre> tags, extract the JS between
          // them.
          const preMatch = text.match(/<pre[^>]*>([\s\S]*?)<\/pre>/);
          if (preMatch) {
            const inner = preMatch[1];
            const innerMatch = inner.match(/\[[\s\S]*?\]/);
            if (innerMatch) arrayText = innerMatch[0];
          }
        }
        if (arrayText) {
          try {
            return JSON.parse(arrayText);
          } catch (e) {
            console.error('Failed to parse signals array', e);
          }
        }
        // Fallback: attempt to eval the text and capture SIGNALS
        try {
          const exports = {};
          eval(text + '; exports.SIGNALS = SIGNALS;');
          return exports.SIGNALS || [];
        } catch (e2) {
          console.error('Failed to eval signals dataset', e2);
        }
      } catch (err) {
        console.error('Failed to fetch signals dataset', err);
      }
      return [];
    }

    (async function () {
      // Create the map centred roughly on Pennsylvania
      const map = L.map('map').setView([40.9, -77.7], 7);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap'
      }).addTo(map);

      // Add geocoder control with suggestion UI
      const geocoderCtl = L.Control.geocoder({
        defaultMarkGeocode: false
      }).on('markgeocode', function (e) {
        const place = e.geocode;
        document.getElementById('addr').value = place.name;
      }).addTo(map);

      // Marker cluster and storage
      const cluster = L.markerClusterGroup({ disableClusteringAtZoom: 12 });
      const markers = [];

      // Load the signals dataset
      const SIGNALS = await fetchSignals();
      if (Array.isArray(SIGNALS)) {
        for (const s of SIGNALS) {
          if (!isFinite(s.lat) || !isFinite(s.lon)) continue;
          const marker = L.circleMarker([s.lat, s.lon], {
            radius: 5,
            color: '#ff0000',
            fillColor: '#ff4d4d',
            fillOpacity: 0.8,
            weight: 1
          }).bindPopup(
                 `Signal ${s.id} AADT: ${fmt(s.aadt)} Truck %: ${fmt(s.truckPct)} Route: ${s.stateRoute || ''} District: ${s.district || ''} County: ${s.countyCode || ''}`
          );
          marker._data = s;
          cluster.addLayer(marker);
          markers.push(marker);
        }
        map.addLayer(cluster);
      }

      // Variables to track search marker and circle
      let searchCircle = null;
      let searchMarker = null;

      // Haversine distance in miles
      function haversineMi(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // meters
        const toRad = (d) => (d * Math.PI) / 180;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(toRad(lat1)) *
            Math.cos(toRad(lat2)) *
            Math.sin(dLon / 2) ** 2;
        const d = 2 * R * Math.asin(Math.sqrt(a));
        return d / 1609.344; // miles
      }

      function fmt(v) {
        return v === null || v === undefined || isNaN(v)
          ? ''
          : Number(v).toLocaleString();
      }

      function milesToMeters(mi) {
        return mi * 1609.344;
      }

      // Click handler for Find Nearby AADT
      document.getElementById('go').addEventListener('click', async () => {
        const q = document.getElementById('addr').value.trim();
        const radiusMiles = parseFloat(document.getElementById('radius').value);
        const limit = parseInt(document.getElementById('limit').value, 10);
        if (!q) {
          alert('Please enter an address.');
          return;
        }
        // Geocode using Nominatim
        const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&q=${encodeURIComponent(q)}`;
        let lat, lon;
        try {
          const resp = await fetch(url, { headers: { Accept: 'application/json' } });
          const data = await resp.json();
          if (!data.length) throw new Error('No match');
          lat = parseFloat(data[0].lat);
          lon = parseFloat(data[0].lon);
        } catch (e) {
          alert('Could not geocode that address. Try a different one.');
          return;
        }
        // Place marker & circle
        if (searchMarker) map.removeLayer(searchMarker);
        if (searchCircle) map.removeLayer(searchCircle);
        searchMarker = L.marker([lat, lon], { draggable: true })
          .addTo(map)
          .bindPopup('Search center')
          .openPopup();
        searchCircle = L.circle([lat, lon], {
          radius: milesToMeters(radiusMiles),
          color: '#1b8ae6',
          fillColor: '#6cc3ff',
          fillOpacity: 0.08,
        }).addTo(map);
        map.fitBounds(searchCircle.getBounds(), { padding: [40, 40] });
        // Filter signals
        cluster.clearLayers();
        const results = [];
        for (const m of markers) {
          const dMi = haversineMi(lat, lon, m._data.lat, m._data.lon);
          if (dMi <= radiusMiles) {
            results.push({ ...m._data, dist: dMi, _marker: m });
          }
        }
        results.sort((a, b) => a.dist - b.dist);
        const capped = results.slice(0, limit);
        // Add back to cluster only capped results
        for (const r of capped) cluster.addLayer(r._marker);
        // Update table
        document.getElementById('summary').textContent = `Found ${results.length} signal(s) within ${radiusMiles} mile(s). Showing ${capped.length}.`;
        const tbody = document.querySelector('#results tbody');
        tbody.innerHTML = '';
        capped.forEach((r, i) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${i + 1}</td><td>#${r.id}</td><td>${fmt(r.aadt)}</td><td>${fmt(r.truckPct)}</td><td>${r.stateRoute || ''}</td><td>${r.dist.toFixed(2)}</td>`;
          tr.addEventListener('click', () => {
            map.setView([r.lat, r.lon], 15);
            r._marker.openPopup();
          });
          tbody.appendChild(tr);
        });
        // Allow dragging of search marker to refine centre
        searchMarker.on('dragend', () => {
          const p = searchMarker.getLatLng();
          document.getElementById('addr').value = `${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`;
        });
      });

      // Refresh map button
      document.getElementById('refresh').addEventListener('click', () => {
        cluster.clearLayers();
        markers.forEach((m) => cluster.addLayer(m));
        if (searchCircle) {
          map.removeLayer(searchCircle);
          searchCircle = null;
        }
        if (searchMarker) {
          map.removeLayer(searchMarker);
          searchMarker = null;
        }
        document.getElementById('summary').textContent = 'Map reset. Enter a new address to search.';
        document.querySelector('#results tbody').innerHTML = '';
      });

      // Export CSV button
      document.getElementById('export').addEventListener('click', () => {
        if (!markers.length) {
          alert('No data to export. Try running a search first.');
          return;
        }
        let csv = 'SignalID,AADT,TruckPct,Route,Distance(mi)\n';
        const rows = markers.map((m) => ({
          id: m._data.id,
          aadt: m._data.aadt ?? '',
          truckPct: m._data.truckPct ?? '',
          stateRoute: m._data.stateRoute ?? '',
          dist: ''
        }));
        rows.forEach((r) => {
          csv += `${r.id},${r.aadt},${r.truckPct},${r.stateRoute},${r.dist}\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv' });
        const urlObj = URL.createObjectURL(blob);
        const a = Object.assign(document.createElement('a'), { href: urlObj, download: 'aadt_results.csv' });
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(urlObj);
      });
    })();
  </script>
</body>
</html>